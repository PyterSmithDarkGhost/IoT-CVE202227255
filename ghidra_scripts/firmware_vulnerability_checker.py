# Data flow-based analysis for determining whether or not a given firmware is affected by CVE-2022-27255

#@author ogalland, ogianatiempo
#@category Analysis.MIPS
#@keybinding 
#@menupath 
#@toolbar 

from ghidra.program.util import DefinedDataIterator
from ghidra.program.model.symbol import DataRefType
from ghidra.app.decompiler import DecompileOptions
from ghidra.app.decompiler import DecompInterface
from ghidra.util.task import ConsoleTaskMonitor

def getCodeReferencesToString(aString):
	strOccurrences = {x.address for x in DefinedDataIterator.definedStrings(currentProgram) if x.value == aString}
	res =  getCodeReferencesToAny(strOccurrences)
	return list(res)

def getReferencesByType(addr):
	refs = getReferencesTo(addr)
	codeRefs = set()
	dataRefs = set()
	for ref in refs:
		if ref.referenceType in [DataRefType.PARAM, DataRefType.READ]:
			codeRefs.add(ref)
		elif ref.referenceType == DataRefType.DATA:
			dataRefs.add(ref)
	return codeRefs, dataRefs

def getReferencesByTypeToAny(addrs):
	codeRefs = set()
	dataRefs = set()
	for addr in addrs:
		c,d = getReferencesByType(addr)
		codeRefs = codeRefs.union(c)
		dataRefs = dataRefs.union(d)
	return codeRefs, dataRefs

def getCodeReferencesToAny(addrs):
	codeRefs, dataRefs = getReferencesByTypeToAny(addrs)
	# Since many string references in the firmwares we analysed involved
	# multiple dereferences, we check for up to 10 levels of data references.
	# 10 should be an overkill, though
	i = 0
	while len(dataRefs) > 0:
		newCodeRefs, newDataRefs = getReferencesByTypeToAny({ref.fromAddress for ref in dataRefs})
		codeRefs = codeRefs.union(newCodeRefs)
		dataRefs = newDataRefs
		i+=1
		if i > 10:
			return codeRefs
	return codeRefs

def mapFunctionCallsInFunction(function, targetFunction):
	ifc = DecompInterface()
	ifc.openProgram(currentProgram)
	ifc.setOptions(DecompileOptions())
	monitor = ConsoleTaskMonitor()
	dec = ifc.decompileFunction(targetFunction, 60, monitor)
	high_func = dec.getHighFunction()
	if high_func:
		opiter = high_func.getPcodeOps()
		while opiter.hasNext():
			op = opiter.next()
			mnemonic = str(op.getMnemonic())
			if mnemonic == "CALL":
				function(op)

class VulnCallFinder():
	def process(self, op):
		srcAddr = op.getSeqnum().getTarget()
		if self.__isCallVulnerable(op):
			print('Vulnerable!')
			print(srcAddr)

	def __isCallVulnerable(self, op):
		# we will check for all the conditions that a vulnerable
		# function call pattern must match

		# 1)
		# g(_, _)
		inputs = op.getInputs()
		if len(inputs) < 3:
			return False
		firstArg = inputs[1]

		# 2)
		# g(stack_buffer, _)
		if not self.__isStackDerived(firstArg):
			return False

		# 3)
		# v2 = f(_, constant)
		# g(stack_buffer, v2)
		secondArg = inputs[2]
		latestCallOp = self.__getCallDef(secondArg)
		if not latestCallOp:
			return False
		latestCallInputs = latestCallOp.getInputs()
		if len(latestCallInputs) < 3 or not latestCallInputs[2].isConstant():
			return False

		# 4)
		# v1 = h(_, constant)
		# v2 = f(v1, constant)
		# g(stack_buffer, v2)
		latestCallFirstArg = latestCallInputs[1]
		secondLatestCallOp = self.__getCallDef(latestCallFirstArg)
		if not secondLatestCallOp:
			return False
		secondLatestCallInputs = secondLatestCallOp.getInputs()
		if len(secondLatestCallInputs) < 3 or not secondLatestCallInputs[2].isConstant():
			return False

		# 5)
		# v1 = f(_, constant)
		# v2 = f(v1, constant)
		# g(stack_buffer, v2)
		if latestCallInputs[0].getAddress() != secondLatestCallInputs[0].getAddress():
			return False

		# 6)
		# v1 = f(_, 0x20)
		# v2 = f(v1, 0x20)
		# g(stack_buffer, v2)
		vuln = secondLatestCallInputs[2].getAddress() == latestCallInputs[2].getAddress() and \
			secondLatestCallInputs[2].getAddress().isConstantAddress() and \
			secondLatestCallInputs[2].getAddress().getOffset() == 0x20
		
		return vuln

	def __getCallDef(self, varnode):
		op = varnode.getDef()
		if not op:
			return None
		i = 0
		while op and op.getMnemonic() != 'CALL':
			op = op.getInputs()[0].getDef()
			i += 1
			if i > 1000:
				break
		return op

	def __getRegisterName(self, varnode):
		reg = currentProgram.getRegister(varnode.getAddress(), varnode.getSize())
		if not reg:
			return None
		return reg.getName()

	def __isStackDerived(self, varnode):
		ops = [varnode.getDef()]
		i = 0
		while len(ops) > 0:
			op = ops.pop()
			# if the definition for a varnode involves doing arithmetic with the
			# stack pointer, we assume that it is 'stack derived', and hence treat
			# it as a potential pointer to the stack
			if not op:
				continue
			elif any(self.__getRegisterName(input) == 'sp' for input in op.getInputs()):
				return True
			elif any(input.getAddress().getAddressSpace().isStackSpace() for input in op.getInputs()):
				return True
			else:
				for input in op.getInputs():
					if input.isRegister() and input.getDef() not in ops:
						ops.append(input.getDef())
			i += 1
			if i > 1000:
				break
		return False
			

finder = VulnCallFinder()
# we will only scan functions containing references to these SIP-ALG related strings
stringsReferences = getCodeReferencesToString(u'm=audio %lu') + \
	getCodeReferencesToString(u'IP4') + \
	getCodeReferencesToString(u'c=') + \
	getCodeReferencesToString(u'm=')

functions = {getFunctionBefore(ref.fromAddress) for ref in stringsReferences}
map(lambda f: mapFunctionCallsInFunction(finder.process, f), functions)
