#include <stdint.h>
#include "main.h"

#define printf ((void (*)(char * format, ...)) 0x8011557D) // 16 bit
#define socket ((int (*)(int domain, int type, int protocol)) 0x8011B894) // 32 bit
#define connect ((int (*)(int sockfd, const struct sockaddr *addr, unsigned int addrlen)) 0x8011B540) // 32 bit
#define close ((int (*) (int fd)) 0x8011A0F4) // 32 bit
#define memset ((void (*)(void *s, int c, unsigned int n)) 0x8010E0E0) // 32 bit
#define malloc ((void * (*)(unsigned int)) 0x80111B7D) // 16 bit
#define free ((void (*) (void *ptr)) 0x80111BE5) // 16 bit

#define get_errno ((int *(*)()) 0x80118EF1) // 16 bit
#define get_errno_message ((char *(*)(int)) 0x80118ED5) // 16 bit

#define strtol ((long int (*)(char *nptr, char **endptr, int base))0x80113035)// 16 bit
#define ip_str_to_number ((int (*) (char *ip_str)) 0x8011BBAD) // 16 bit

#define cyg_thread_create ((void (*)(unsigned int priority, void *entry, void *entry_data, char* name, void* stack_base, unsigned int stack_size, unsigned int *handle, void *thread_data)) 0x8010E998) // 32 bit (priority max: 0, min: 31)
#define cyg_thread_resume ((void (*)(unsigned int handle)) 0x8010E900) // 32 bit
#define cyg_thread_kill ((void (*)(unsigned int *handle)) 0x8010E8F8) // 32 bit
#define cyg_thread_delete ((void (*)(unsigned int *handle)) 0x8010E940) // 32 bit
#define cyg_thread_exit ((void (*)(void)) 0x8010E990) // 32 bit

#define sleep ((unsigned int (*)(unsigned int seconds)) 0x801182B8) // 32 bit

unsigned short *top_ports;

#define REPORT_RESULT(range_start, range_end, delta) \
	{\
		printf("Results for range [%d, %d):\n", range_start + delta, range_end + delta); \
		int somePortOpen = 0; \
		for (unsigned int i = range_start; i < range_end; i++) { \
			if (ports_state[i]) { \
				printf("\tPort %d is open!\n", i + delta); \
				somePortOpen = 1; \
			} \
		} \
		if (!somePortOpen) { \
			printf("\tNo ports open!\n"); \
		}\
	}

// We use shared memory in a safe way in order to communicate between threads
// this helps us avoid the use of mutexes
uint8_t is_alive[THREAD_COUNT];
uint8_t should_die[THREAD_COUNT];

void scan_ports(thread_info *thread);
void destroy(thread_info *thread);
void wait_and_destroy(thread_info *thread);

int main (int argc, char **argv) {
	unsigned int *tcp_keepinit;
	unsigned int tcp_keepinit_bkp;
	unsigned int port_count;
	unsigned int ip;
	uint8_t *ports_state;
	thread_info *threads;

	if (argc != 1){
		printf("Usage: pwl [ip]\n");
		return -1;
	}

	memset(is_alive, 0, THREAD_COUNT);
	memset(should_die, 0, THREAD_COUNT);

	port_count = 1025;
	top_ports = (unsigned short *) malloc(port_count * sizeof(unsigned short));

	if (!top_ports) {
		printf("Failed to allocate top port array, aborting!\n");
		return -1;
	}

	printf("Scanning port ranges [0, 1025)...\n");
	for (unsigned int i = 0; i < 1025; i++)
	{
		top_ports[i] = i;
	}

	threads = (thread_info*) malloc(THREAD_COUNT * sizeof(thread_info));
	if (threads == 0) {
		printf("Failed to allocate thread handle array, aborting!\n");
		return -1;
	}
	memset(threads, 0, THREAD_COUNT * sizeof(thread_info));

	ports_state = (uint8_t *) malloc(port_count);
	if (ports_state == 0) {
		printf("Failed to allocate port state array, aborting!\n");
		free(top_ports);
		free(threads);
		return -1;
	}
	memset(ports_state, 0, port_count);

	ip = ip_str_to_number(argv[0]);

	tcp_keepinit = (unsigned int *) 0x8070d55c;
	tcp_keepinit_bkp = *tcp_keepinit;
	
	// we overwrite the tcp keep init timeout in order to make the connect-scan faster
	*tcp_keepinit = 100; 
	
	for (int i = 0; i < THREAD_COUNT; i++)
	{
		unsigned int stack_size = 0x1000; // do we need so much memory?
		void *stack = malloc(stack_size);
		void *thread_data = malloc(0x100);
		if (stack == 0 || thread_data == 0) {
			printf("Failed to allocate thread memory, aborting!\n");
			for (int i = 0; i < THREAD_COUNT; i++) {
				destroy(&threads[i]);
			}
			free(top_ports);
			free(ports_state);
			free(threads);
			return -1;
		}

		threads[i].idx = i;
		threads[i].stack = stack;
		threads[i].data = thread_data;
		threads[i].task.start = (port_count / THREAD_COUNT) * i;
		threads[i].task.end = threads[i].task.start + (port_count / THREAD_COUNT);
		if (i == THREAD_COUNT - 1) {
			threads[i].task.end = port_count; // the last thread should scan whatever ports are left
		}
		threads[i].task.ports_state = ports_state;
		threads[i].task.ip = ip;

		cyg_thread_create(5, &scan_ports, &threads[i], "scanner thread", stack, stack_size, &threads[i].handle, thread_data);

		is_alive[i] = 1;
		should_die[i] = 0;
		cyg_thread_resume(threads[i].handle);
	}
	
	for (int i = 0; i < THREAD_COUNT; i++) {
		wait_and_destroy(&threads[i]);
	}

	REPORT_RESULT(0, 1025, 0);
	
	*tcp_keepinit = tcp_keepinit_bkp;
	free(top_ports);
	free(ports_state);
	free(threads);
	return 0;
}

void scan_ports(thread_info *thread) {
	sockaddr_in sa;

	sa.sin_len = 0;
	for (int i = 0; i < 24; i++) sa.sin_zero[i] = 0;
	sa.sin_family = AF_INET;
	sa.sin_addr.s_addr = thread->task.ip;

	printf("Im thread %d. Ima scan from %d to %d.\n", thread->idx, thread->task.start, thread->task.end);

	for (unsigned int i = thread->task.start;
		!should_die[thread->idx] && i < thread->task.end; i++)
	{
		// printf("Testing port %d.\n", top_ports[i]);
		sa.sin_port = top_ports[i];
		int s = socket(AF_INET, SOCK_STREAM, 0); 

		if (s < 0) {
			int *err = get_errno();
			char *err_msg = get_errno_message(*err);
			printf("socket error : %s\n", err_msg);
			break;
		}

		if (connect(s, &sa, sizeof(sockaddr_in)) >= 0) {
			thread->task.ports_state[i] = 1;
		}

		close(s);
	}

	is_alive[thread->idx] = 0;
	cyg_thread_exit();
}

void destroy(thread_info *thread) {
	should_die[thread->idx] = 1;
	wait_and_destroy(thread);
}

void wait_and_destroy(thread_info *thread) {
	while (is_alive[thread->idx]) {
		sleep(1);
	}
	if (thread->data != 0)
		free(thread->data);
	if (thread->stack != 0)
		free(thread->stack);
	cyg_thread_delete(thread->handle);
}